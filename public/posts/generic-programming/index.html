<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-1QE8P64SZS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1QE8P64SZS');
</script>

<meta name="robots" content="index, follow">
<title>這次是對 Generic programming 的思考 | </title>
<meta name="keywords" content="程式設計">
<meta name="description" content="程式寫了幾年後，有了些感性認識，無論是想寫的更好，或想學其他語言但覺得太多種學不完、也不知道怎麼學，只學了表面。
如果你也有一樣的疑問，不妨瞭解下 Programming Paradigm 程式設計方法，透過程式語言的發展歷史，瞭解主流的幾種程式語言的特性，在比較與歸納中去思考程式設計的本質為何？從更高的維度去思考，就能提高程式設計能力。
Programming Paradigm 將程式語言分成不同的設計風格，這系列文章會透過幾種語言(C、C&#43;&#43;、Java、Go、Python、JavaScript)來了解「如何寫出更通用、可重用的程式」。
這次是對泛型 Generic programming 的思考。
C 語言
許多人第一個學習的是 C 語言，能做到微觀非常精細的操作，讓工程師自由控制底層、系統的細節，但在程式碼的組織、功能上有許多缺點，因此現在有許多 C Like 語言都是以 C 語言為基礎拓展，並改善 C 語言的問題。
C 語言的特性

靜態弱型別：使用變數需要定義資料型別，但類型之間會自動轉型。
不同變數可以用 struct 組合成新的資料型別。
可以用 typedef 關鍵字定義資料型別的別名，達到變數資料型別的抽象。
有變數的作用域、遞迴功能。
參數以值傳遞，也可以傳指標。
透過指標能對記憶體做底層控制，但也增加了寫作的複雜度。
編譯預處理可以讓編譯更有彈性，做跨平台。

C 語言的 swap
void swap(int* x, int* y) {
    int tmp = *x;
    *x = *y;
    *y = tmp;
}
這段程式重點有二個

傳指標是因為函式的參數 x、y 只是引數的 copy，函式內修改參數無法影響外部的引數。
問題在於這函式只適用於 int，double、float 都不能用，這是靜態類型語言面臨的問題。

資料型別
透過 swap() 能發現，靜態類型的語言要做到泛型，首先要處理的是資料型別的問題

泛型程式設計，對於靜態類性語言首先要做的就是抽象資料型別。
C 語言的編譯器會做自動轉型，讓寫程式方便一點，也可以做到一點點的泛型。
C 語言做轉型，可能出現問題；例如一個 double 類型陣列，a[2] 尋址公式為 a &#43; sizeof(double) * 2，如果轉成 int 陣列，尋址公式變成 a &#43; sizeof(int) * 2，於是訪問到不同記憶體位址而出現錯誤。

C 語言的泛型
要讓 swap() 能通用各種型別，C 語言可以透過 void* 做到泛型">
<meta name="author" content="">
<link rel="canonical" href="https://marc-tech.zeabur.app/posts/generic-programming/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.0ae5145492ee91fac5036e87965b1395678c6daee907d175e51d2af65e49fe1b.css" integrity="sha256-CuUUVJLukfrFA26HllsTlWeMba7pB9F15R0q9l5J/hs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.555af97124d54bb1457985dd081b8f5616a48103aafeb30ac89fde835d65aa6c.js" integrity="sha256-VVr5cSTVS7FFeYXdCBuPVhakgQOq/rMKyJ/eg11lqmw="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://marc-tech.zeabur.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://marc-tech.zeabur.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://marc-tech.zeabur.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://marc-tech.zeabur.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://marc-tech.zeabur.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://marc-tech.zeabur.app/posts/generic-programming/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1QE8P64SZS"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1QE8P64SZS');
        }
      </script><meta property="og:title" content="這次是對 Generic programming 的思考" />
<meta property="og:description" content="程式寫了幾年後，有了些感性認識，無論是想寫的更好，或想學其他語言但覺得太多種學不完、也不知道怎麼學，只學了表面。
如果你也有一樣的疑問，不妨瞭解下 Programming Paradigm 程式設計方法，透過程式語言的發展歷史，瞭解主流的幾種程式語言的特性，在比較與歸納中去思考程式設計的本質為何？從更高的維度去思考，就能提高程式設計能力。
Programming Paradigm 將程式語言分成不同的設計風格，這系列文章會透過幾種語言(C、C&#43;&#43;、Java、Go、Python、JavaScript)來了解「如何寫出更通用、可重用的程式」。
這次是對泛型 Generic programming 的思考。
C 語言
許多人第一個學習的是 C 語言，能做到微觀非常精細的操作，讓工程師自由控制底層、系統的細節，但在程式碼的組織、功能上有許多缺點，因此現在有許多 C Like 語言都是以 C 語言為基礎拓展，並改善 C 語言的問題。
C 語言的特性

靜態弱型別：使用變數需要定義資料型別，但類型之間會自動轉型。
不同變數可以用 struct 組合成新的資料型別。
可以用 typedef 關鍵字定義資料型別的別名，達到變數資料型別的抽象。
有變數的作用域、遞迴功能。
參數以值傳遞，也可以傳指標。
透過指標能對記憶體做底層控制，但也增加了寫作的複雜度。
編譯預處理可以讓編譯更有彈性，做跨平台。

C 語言的 swap
void swap(int* x, int* y) {
    int tmp = *x;
    *x = *y;
    *y = tmp;
}
這段程式重點有二個

傳指標是因為函式的參數 x、y 只是引數的 copy，函式內修改參數無法影響外部的引數。
問題在於這函式只適用於 int，double、float 都不能用，這是靜態類型語言面臨的問題。

資料型別
透過 swap() 能發現，靜態類型的語言要做到泛型，首先要處理的是資料型別的問題

泛型程式設計，對於靜態類性語言首先要做的就是抽象資料型別。
C 語言的編譯器會做自動轉型，讓寫程式方便一點，也可以做到一點點的泛型。
C 語言做轉型，可能出現問題；例如一個 double 類型陣列，a[2] 尋址公式為 a &#43; sizeof(double) * 2，如果轉成 int 陣列，尋址公式變成 a &#43; sizeof(int) * 2，於是訪問到不同記憶體位址而出現錯誤。

C 語言的泛型
要讓 swap() 能通用各種型別，C 語言可以透過 void* 做到泛型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://marc-tech.zeabur.app/posts/generic-programming/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T20:46:22&#43;08:00" />
<meta property="article:modified_time" content="2022-05-01T20:46:22&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="這次是對 Generic programming 的思考"/>
<meta name="twitter:description" content="程式寫了幾年後，有了些感性認識，無論是想寫的更好，或想學其他語言但覺得太多種學不完、也不知道怎麼學，只學了表面。
如果你也有一樣的疑問，不妨瞭解下 Programming Paradigm 程式設計方法，透過程式語言的發展歷史，瞭解主流的幾種程式語言的特性，在比較與歸納中去思考程式設計的本質為何？從更高的維度去思考，就能提高程式設計能力。
Programming Paradigm 將程式語言分成不同的設計風格，這系列文章會透過幾種語言(C、C&#43;&#43;、Java、Go、Python、JavaScript)來了解「如何寫出更通用、可重用的程式」。
這次是對泛型 Generic programming 的思考。
C 語言
許多人第一個學習的是 C 語言，能做到微觀非常精細的操作，讓工程師自由控制底層、系統的細節，但在程式碼的組織、功能上有許多缺點，因此現在有許多 C Like 語言都是以 C 語言為基礎拓展，並改善 C 語言的問題。
C 語言的特性

靜態弱型別：使用變數需要定義資料型別，但類型之間會自動轉型。
不同變數可以用 struct 組合成新的資料型別。
可以用 typedef 關鍵字定義資料型別的別名，達到變數資料型別的抽象。
有變數的作用域、遞迴功能。
參數以值傳遞，也可以傳指標。
透過指標能對記憶體做底層控制，但也增加了寫作的複雜度。
編譯預處理可以讓編譯更有彈性，做跨平台。

C 語言的 swap
void swap(int* x, int* y) {
    int tmp = *x;
    *x = *y;
    *y = tmp;
}
這段程式重點有二個

傳指標是因為函式的參數 x、y 只是引數的 copy，函式內修改參數無法影響外部的引數。
問題在於這函式只適用於 int，double、float 都不能用，這是靜態類型語言面臨的問題。

資料型別
透過 swap() 能發現，靜態類型的語言要做到泛型，首先要處理的是資料型別的問題

泛型程式設計，對於靜態類性語言首先要做的就是抽象資料型別。
C 語言的編譯器會做自動轉型，讓寫程式方便一點，也可以做到一點點的泛型。
C 語言做轉型，可能出現問題；例如一個 double 類型陣列，a[2] 尋址公式為 a &#43; sizeof(double) * 2，如果轉成 int 陣列，尋址公式變成 a &#43; sizeof(int) * 2，於是訪問到不同記憶體位址而出現錯誤。

C 語言的泛型
要讓 swap() 能通用各種型別，C 語言可以透過 void* 做到泛型"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://marc-tech.zeabur.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "這次是對 Generic programming 的思考",
      "item": "https://marc-tech.zeabur.app/posts/generic-programming/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "這次是對 Generic programming 的思考",
  "name": "這次是對 Generic programming 的思考",
  "description": "程式寫了幾年後，有了些感性認識，無論是想寫的更好，或想學其他語言但覺得太多種學不完、也不知道怎麼學，只學了表面。\n如果你也有一樣的疑問，不妨瞭解下 Programming Paradigm 程式設計方法，透過程式語言的發展歷史，瞭解主流的幾種程式語言的特性，在比較與歸納中去思考程式設計的本質為何？從更高的維度去思考，就能提高程式設計能力。\nProgramming Paradigm 將程式語言分成不同的設計風格，這系列文章會透過幾種語言(C、C++、Java、Go、Python、JavaScript)來了解「如何寫出更通用、可重用的程式」。\n這次是對泛型 Generic programming 的思考。\nC 語言 許多人第一個學習的是 C 語言，能做到微觀非常精細的操作，讓工程師自由控制底層、系統的細節，但在程式碼的組織、功能上有許多缺點，因此現在有許多 C Like 語言都是以 C 語言為基礎拓展，並改善 C 語言的問題。\nC 語言的特性\n靜態弱型別：使用變數需要定義資料型別，但類型之間會自動轉型。 不同變數可以用 struct 組合成新的資料型別。 可以用 typedef 關鍵字定義資料型別的別名，達到變數資料型別的抽象。 有變數的作用域、遞迴功能。 參數以值傳遞，也可以傳指標。 透過指標能對記憶體做底層控制，但也增加了寫作的複雜度。 編譯預處理可以讓編譯更有彈性，做跨平台。 C 語言的 swap void swap(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; } 這段程式重點有二個\n傳指標是因為函式的參數 x、y 只是引數的 copy，函式內修改參數無法影響外部的引數。 問題在於這函式只適用於 int，double、float 都不能用，這是靜態類型語言面臨的問題。 資料型別 透過 swap() 能發現，靜態類型的語言要做到泛型，首先要處理的是資料型別的問題\n泛型程式設計，對於靜態類性語言首先要做的就是抽象資料型別。 C 語言的編譯器會做自動轉型，讓寫程式方便一點，也可以做到一點點的泛型。 C 語言做轉型，可能出現問題；例如一個 double 類型陣列，a[2] 尋址公式為 a + sizeof(double) * 2，如果轉成 int 陣列，尋址公式變成 a + sizeof(int) * 2，於是訪問到不同記憶體位址而出現錯誤。 C 語言的泛型 要讓 swap() 能通用各種型別，C 語言可以透過 void* 做到泛型\n",
  "keywords": [
    "程式設計"
  ],
  "articleBody": "程式寫了幾年後，有了些感性認識，無論是想寫的更好，或想學其他語言但覺得太多種學不完、也不知道怎麼學，只學了表面。\n如果你也有一樣的疑問，不妨瞭解下 Programming Paradigm 程式設計方法，透過程式語言的發展歷史，瞭解主流的幾種程式語言的特性，在比較與歸納中去思考程式設計的本質為何？從更高的維度去思考，就能提高程式設計能力。\nProgramming Paradigm 將程式語言分成不同的設計風格，這系列文章會透過幾種語言(C、C++、Java、Go、Python、JavaScript)來了解「如何寫出更通用、可重用的程式」。\n這次是對泛型 Generic programming 的思考。\nC 語言 許多人第一個學習的是 C 語言，能做到微觀非常精細的操作，讓工程師自由控制底層、系統的細節，但在程式碼的組織、功能上有許多缺點，因此現在有許多 C Like 語言都是以 C 語言為基礎拓展，並改善 C 語言的問題。\nC 語言的特性\n靜態弱型別：使用變數需要定義資料型別，但類型之間會自動轉型。 不同變數可以用 struct 組合成新的資料型別。 可以用 typedef 關鍵字定義資料型別的別名，達到變數資料型別的抽象。 有變數的作用域、遞迴功能。 參數以值傳遞，也可以傳指標。 透過指標能對記憶體做底層控制，但也增加了寫作的複雜度。 編譯預處理可以讓編譯更有彈性，做跨平台。 C 語言的 swap void swap(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; } 這段程式重點有二個\n傳指標是因為函式的參數 x、y 只是引數的 copy，函式內修改參數無法影響外部的引數。 問題在於這函式只適用於 int，double、float 都不能用，這是靜態類型語言面臨的問題。 資料型別 透過 swap() 能發現，靜態類型的語言要做到泛型，首先要處理的是資料型別的問題\n泛型程式設計，對於靜態類性語言首先要做的就是抽象資料型別。 C 語言的編譯器會做自動轉型，讓寫程式方便一點，也可以做到一點點的泛型。 C 語言做轉型，可能出現問題；例如一個 double 類型陣列，a[2] 尋址公式為 a + sizeof(double) * 2，如果轉成 int 陣列，尋址公式變成 a + sizeof(int) * 2，於是訪問到不同記憶體位址而出現錯誤。 C 語言的泛型 要讓 swap() 能通用各種型別，C 語言可以透過 void* 做到泛型\nvoid swap(void* x, void* y, size_t size) { char tmp[size]; memcpy(tmp, x, size); memcpy(x, y, size); memcpy(y, tmp, size); } 比起 int 版本，有幾個改變\n增加了 size 參數，因為用 void* 後，類型被抽象掉了，編譯器無法知道類型的大小，需要手動處理。 用 memcpy()，因為類型被抽象後，沒辦法用 = 表達式賦值了，傳進來的甚至可能是 struct，因此只能用記憶體複製的方法。 buffer 改成用 tmp[size] 陣列。 為了泛型，增加了程式寫作的複雜度；而且如果要 swap 字串陣列，類型是 char*，那參數的資料型別要用 void**，介面不一致，就無法定義了。\n除了 void* 以外，C 語言還能用巨集(macro) 做到泛型\n#define swap(x, y, size) {\\ char tmp[size]; \\ memcpy(tmp, x, size); \\ memcpy(x, y, size); \\ memcpy(y, tmp, size); \\ } 巨集雖然不像 void* 會隱藏資料型別，可以用 sizeof(x) 來檢查傳入參數的 size，但如果類型是 char*，sizeof(x) 取得的是指標的 size，而非 char 的 size，因此還是必須把 size 交給呼叫的人去處理。\n另外，巨集還有重複執行問題，例如\n#define min(x, y) ((x)\u003c(y) ? (x) : (y)) min(i++, j++)，本意是比較完後，對變數做累加，但因為巨集替換，會導致 i 或 j 其中一個被累加二次 min(foo(), bar())，本意是比較 foo()、bar() 的返回值，但巨集替換後，foo()、bar() 其中一個函數會被呼叫二次。 C 語言的泛型，無論使用 void* 或巨集，介面都變更複雜，且太過寬鬆，無法檢查資料型別，只能直接在記憶體上操作、複製，風險較大，可能在某些條件就會出錯。\n更複雜的泛型範例 search function 在 int 陣列中搜尋 target，並返回索引，沒找到返回 -1\nint search(int* a, size_t size, int target) { for(int i=0; i\u003csize; i++) { if (a[i] == target) { return i; } } return -1; } 如果把這個 search function 改成泛型的\nint search(void* a, size_t size, void* target, size_t elem_size, int(*cmpFn)(void*, void*)) { for(int i=0; i\u003csize; i++) { if ( cmpFn ((unsigned char *)a + elem_size * i, target) == 0 ) { return i; } } return -1; } 增加 elem_size 參數，表示陣列裡元素的 size ，走訪陣列時才能正確移動指標到下一個元素。 用 cmpFn 比較是否相等，因為不同資料型別的比較實作方式不同，int 用 == 即可，而 struct 就必須自己實作比較方法。 沒有用 memcmp() 是因為如果陣列是一個指標陣列，或者是 struct 陣列且 struct 內有指標成員，用 memcmp() 是在比較指標的記憶體位址，但實際要比較的應是指標指向的值，而非指標本身。 呼叫者必須提供類似以下的函數做比較\nint int_cmp(int* x, int* y) { return *x - *y; } int string_cmp(char* x, char* y) { return strcmp(x, y); } typedef struct _account { char name[10]; char id[20]; } Account; int account_cmp(Account* x, Account* y) { int n = strcmp(x-\u003ename, y-\u003ename); if (n != 0) return n; return strcmp(x-\u003eid, y-\u003eid); } 目前 search function 為了支援各種資料型別，已經變得複雜，但還是只能支援陣列、順序型的資料結構，如果想要支援非順序型的資料結構，如 stack、heap、hash table、tree、graph，那實在是複雜到寫不下去了。\n透過以上幾個範例可以發現 C 語言的問題\n如果一個算法想支援不同的資料型別，必須使用 void* 或巨集，導致型別檢查過於寬鬆，容易產生錯誤。 抽象後的資料型別，無法取得 size，必須由呼叫者自己處理。 更複雜的泛型不只要支援不同的資料型別，還要支援不同的資料結構（資料是在結構裡面），而不同資料結構要處理記憶體分配與釋放、物件之間的複製，其中還有 shallow copy 的問題，造成程式碼複雜度劇增。 C 語言至今沒有解決這些問題，因為當初設計的目的、思想就已經決定 C 語言注定不適合高階、抽象的程式設計方法，所以才有了 C++。\nC++ 語言 早期 C++ 許多功能是對 C 語言的強化、改進，且把兼容 C 作為強制要求，所以 C++ 才設計得這麼複雜；而 C 語言的 C89、C99 也參考了 C++ 做了很多改進。\n九二共識就是沒有共識，我只知道九九共識，依循 C99 規格開發程式。\nC++ 解決了 C 的許多問題\n用 reference 解決指標的問題 用 namespace 解決命名衝突問題 用 try-catch 解決檢查返回值的問題 用 class 解決物件建立、複製、刪除的問題 用 operator overloading 達到操作上的泛型，比如上一篇的 cmpFn 比較函式，再比如 \u003e\u003e 操作符消除 printf() 的資料結構不夠泛型的問題 用 template、virtual function、RTTI 達到更高層次的泛型與多型 用 RAII、smart pointers，解決 C 語言中為了釋放資源而寫的骯髒、容易錯的程式碼 用 STL 解決 C 語言中資料結構、演算法的問題 C++ 的泛型 理想情況下算法與資料型別、資料結構都無關，各種資料結構應該自己處理份內的工作，而算法只關心一個標準的實作方法；而泛型程式設計需要解決幾個問題\n算法的泛型 資料型別的泛型 資料結構(資料的容器)的泛型 C++ 透過幾種方式解決泛型問題，能夠寫出基於抽象的介面的泛型\n透過類別(class)解決資料型別、資料結構的問題 類別裡面有建構子、解構子，處理資源的分配、釋放 複製建構子，表示對記憶體的複製 運算子重載，處理比較的問題 這樣自訂的資料型別用起來就跟內建的一樣 透過模板處理資料型別 模板會根據呼叫者的類型，在編譯時去生成那個模板的程式碼 模板可以用虛擬類型來綁定，就沒有資料型別轉換的問題 模板取代了 C 語言的巨集，並解決了巨集的問題 虛擬函式、RTTI 虛擬函式的多型，在語法上可以支援同一類的型別的泛型 泛型時 RTTI 可以對具體類型做特殊處理 C++ 泛型範例 search function 之前 C 版本的 search() 還有幾個問題\n透過 for(int i=0; i",
  "wordCount" : "1324",
  "inLanguage": "en",
  "datePublished": "2022-05-01T20:46:22+08:00",
  "dateModified": "2022-05-01T20:46:22+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://marc-tech.zeabur.app/posts/generic-programming/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "https://marc-tech.zeabur.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
	<ul id="menu">
            <li>
                <a href="https://marc-tech.zeabur.app/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://marc-tech.zeabur.app/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://marc-tech.zeabur.app/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://marc-tech.zeabur.app/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
        </ul>
        <div class="logo">
            <div class="social-icons">
    <a href="https://github.com/r3nyou" target="_blank" rel="noopener noreferrer me" title="Github">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
    </a>
    <a href="mailto:renyou815@gmail.com" target="_blank" rel="noopener noreferrer me" title="Email">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
    <polyline points="22,6 12,13 2,6"></polyline>
</svg>
    </a>
</div>

        </div>
    </nav>
    <article class="first-entry home-info">
        <header class="entry-header">
            <h1>Not a Real Programmer</h1>
        </header>
        <div class="entry-content">
            <p>Hi, I&rsquo;m Marcus, and I&rsquo;m a mediocre programmer.</p>
        </div>
        <footer class="entry-footer">
            
        </footer>
    </article></header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      這次是對 Generic programming 的思考
    </h1>
    <div class="post-meta">&lt;span title=&#39;2022-05-01 20:46:22 &#43;0800 CST&#39;&gt;May 1, 2022&lt;/span&gt;

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#c-%e8%aa%9e%e8%a8%80" aria-label="C 語言">C 語言</a></li>
                <li>
                    <a href="#c-%e8%aa%9e%e8%a8%80%e7%9a%84-swap" aria-label="C 語言的 swap">C 語言的 swap</a></li>
                <li>
                    <a href="#%e8%b3%87%e6%96%99%e5%9e%8b%e5%88%a5" aria-label="資料型別">資料型別</a></li>
                <li>
                    <a href="#c-%e8%aa%9e%e8%a8%80%e7%9a%84%e6%b3%9b%e5%9e%8b" aria-label="C 語言的泛型">C 語言的泛型</a></li>
                <li>
                    <a href="#%e6%9b%b4%e8%a4%87%e9%9b%9c%e7%9a%84%e6%b3%9b%e5%9e%8b%e7%af%84%e4%be%8b-search-function" aria-label="更複雜的泛型範例 search function">更複雜的泛型範例 search function</a></li>
                <li>
                    <a href="#c-%e8%aa%9e%e8%a8%80-1" aria-label="C&#43;&#43; 語言">C++ 語言</a></li>
                <li>
                    <a href="#c-%e7%9a%84%e6%b3%9b%e5%9e%8b" aria-label="C&#43;&#43; 的泛型">C++ 的泛型</a></li>
                <li>
                    <a href="#c-%e6%b3%9b%e5%9e%8b%e7%af%84%e4%be%8b-search-function" aria-label="C&#43;&#43; 泛型範例 search function">C++ 泛型範例 search function</a></li>
                <li>
                    <a href="#c-%e6%b3%9b%e5%9e%8b%e7%af%84%e4%be%8b-sum-function" aria-label="C&#43;&#43; 泛型範例 sum function">C++ 泛型範例 sum function</a></li>
                <li>
                    <a href="#c-%e6%b3%9b%e5%9e%8b%e6%8a%80%e8%a1%93-%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="C&#43;&#43; 泛型技術 迭代器">C++ 泛型技術 迭代器</a></li>
                <li>
                    <a href="#%e6%9b%b4%e5%a4%9a%e7%9a%84%e6%8a%bd%e8%b1%a1" aria-label="更多的抽象">更多的抽象</a></li>
                <li>
                    <a href="#reduce-%e5%87%bd%e5%bc%8f" aria-label="Reduce 函式">Reduce 函式</a></li>
                <li>
                    <a href="#%e5%9e%8b%e5%88%a5%e7%b3%bb%e7%b5%b1-type-system" aria-label="型別系統 type system">型別系統 type system</a></li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b%e7%9a%84%e6%9c%ac%e8%b3%aa" aria-label="泛型的本質">泛型的本質</a></li>
                <li>
                    <a href="#reference" aria-label="reference">reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>程式寫了幾年後，有了些感性認識，無論是想寫的更好，或想學其他語言但覺得太多種學不完、也不知道怎麼學，只學了表面。</p>
<p>如果你也有一樣的疑問，不妨瞭解下 Programming Paradigm 程式設計方法，透過程式語言的發展歷史，瞭解主流的幾種程式語言的特性，在比較與歸納中去思考程式設計的本質為何？從更高的維度去思考，就能提高程式設計能力。</p>
<p>Programming Paradigm 將程式語言分成不同的設計風格，這系列文章會透過幾種語言(C、C++、Java、Go、Python、JavaScript)來了解「如何寫出更通用、可重用的程式」。</p>
<p>這次是對泛型 Generic programming 的思考。</p>
<h2 id="c-語言">C 語言<a hidden class="anchor" aria-hidden="true" href="#c-語言">#</a></h2>
<p>許多人第一個學習的是 C 語言，能做到微觀非常精細的操作，讓工程師自由控制底層、系統的細節，但在程式碼的組織、功能上有許多缺點，因此現在有許多 C Like 語言都是以 C 語言為基礎拓展，並改善 C 語言的問題。</p>
<p>C 語言的特性</p>
<ul>
<li>靜態弱型別：使用變數需要定義資料型別，但類型之間會自動轉型。</li>
<li>不同變數可以用 struct 組合成新的資料型別。</li>
<li>可以用 typedef 關鍵字定義資料型別的別名，達到變數資料型別的抽象。</li>
<li>有變數的作用域、遞迴功能。</li>
<li>參數以值傳遞，也可以傳指標。</li>
<li>透過指標能對記憶體做底層控制，但也增加了寫作的複雜度。</li>
<li>編譯預處理可以讓編譯更有彈性，做跨平台。</li>
</ul>
<h2 id="c-語言的-swap">C 語言的 swap<a hidden class="anchor" aria-hidden="true" href="#c-語言的-swap">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> x, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>y;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>這段程式重點有二個</p>
<ul>
<li>傳指標是因為函式的參數 x、y 只是引數的 copy，函式內修改參數無法影響外部的引數。</li>
<li>問題在於這函式只適用於 int，double、float 都不能用，這是靜態類型語言面臨的問題。</li>
</ul>
<h2 id="資料型別">資料型別<a hidden class="anchor" aria-hidden="true" href="#資料型別">#</a></h2>
<p>透過 swap() 能發現，靜態類型的語言要做到泛型，首先要處理的是資料型別的問題</p>
<ul>
<li>泛型程式設計，對於靜態類性語言首先要做的就是抽象資料型別。</li>
<li>C 語言的編譯器會做自動轉型，讓寫程式方便一點，也可以做到一點點的泛型。</li>
<li>C 語言做轉型，可能出現問題；例如一個 double 類型陣列，a[2] 尋址公式為 a + sizeof(double) * 2，如果轉成 int 陣列，尋址公式變成 a + sizeof(int) * 2，於是訪問到不同記憶體位址而出現錯誤。</li>
</ul>
<h2 id="c-語言的泛型">C 語言的泛型<a hidden class="anchor" aria-hidden="true" href="#c-語言的泛型">#</a></h2>
<p>要讓 swap() 能通用各種型別，C 語言可以透過 void* 做到泛型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> x, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> y, <span style="color:#66d9ef">size_t</span> size) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> tmp[size];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(tmp, x, size);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(x, y, size);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(y, tmp, size);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比起 int 版本，有幾個改變</p>
<ul>
<li>增加了 size 參數，因為用 void* 後，類型被抽象掉了，編譯器無法知道類型的大小，需要手動處理。</li>
<li>用 memcpy()，因為類型被抽象後，沒辦法用 = 表達式賦值了，傳進來的甚至可能是 struct，因此只能用記憶體複製的方法。</li>
<li>buffer 改成用 tmp[size] 陣列。</li>
</ul>
<p>為了泛型，增加了程式寫作的複雜度；而且如果要 swap 字串陣列，類型是 char*，那參數的資料型別要用 void**，介面不一致，就無法定義了。</p>
<p>除了 void* 以外，C 語言還能用巨集(macro) 做到泛型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define swap(x, y, size) {\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    char tmp[size]; \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    memcpy(tmp, x, size); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    memcpy(x, y, size); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    memcpy(y, tmp, size); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span></code></pre></div><p>巨集雖然不像 void* 會隱藏資料型別，可以用 sizeof(x) 來檢查傳入參數的 size，但如果類型是 char*，sizeof(x) 取得的是指標的 size，而非 char 的 size，因此還是必須把 size 交給呼叫的人去處理。</p>
<p>另外，巨集還有重複執行問題，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define min(x, y) ((x)&lt;(y) ? (x) : (y))
</span></span></span></code></pre></div><ul>
<li>min(i++, j++)，本意是比較完後，對變數做累加，但因為巨集替換，會導致 i 或 j 其中一個被累加二次</li>
<li>min(foo(), bar())，本意是比較 foo()、bar() 的返回值，但巨集替換後，foo()、bar() 其中一個函數會被呼叫二次。</li>
</ul>
<p>C 語言的泛型，無論使用 void* 或巨集，介面都變更複雜，且太過寬鬆，無法檢查資料型別，只能直接在記憶體上操作、複製，風險較大，可能在某些條件就會出錯。</p>
<h2 id="更複雜的泛型範例-search-function">更複雜的泛型範例 search function<a hidden class="anchor" aria-hidden="true" href="#更複雜的泛型範例-search-function">#</a></h2>
<p>在 int 陣列中搜尋 target，並返回索引，沒找到返回 -1</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">==</span> target) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果把這個 search function 改成泛型的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> target,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">size_t</span> elem_size, <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>cmpFn)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">cmpFn</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)a <span style="color:#f92672">+</span> elem_size <span style="color:#f92672">*</span> i, target) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>增加 elem_size 參數，表示陣列裡元素的 size ，走訪陣列時才能正確移動指標到下一個元素。</li>
<li>用 cmpFn 比較是否相等，因為不同資料型別的比較實作方式不同，int 用 == 即可，而 struct 就必須自己實作比較方法。</li>
<li>沒有用 memcmp() 是因為如果陣列是一個指標陣列，或者是 struct 陣列且 struct 內有指標成員，用 memcmp() 是在比較指標的記憶體位址，但實際要比較的應是指標指向的值，而非指標本身。</li>
</ul>
<p>呼叫者必須提供類似以下的函數做比較</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">int_cmp</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> x, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> y) { <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>x <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>y; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">string_cmp</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> x, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> y) { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strcmp</span>(x, y); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _account {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> id[<span style="color:#ae81ff">20</span>];
</span></span><span style="display:flex;"><span>} Account;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">account_cmp</span>(Account<span style="color:#f92672">*</span> x, Account<span style="color:#f92672">*</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#a6e22e">strcmp</span>(x<span style="color:#f92672">-&gt;</span>name, y<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strcmp</span>(x<span style="color:#f92672">-&gt;</span>id, y<span style="color:#f92672">-&gt;</span>id);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>目前 search function 為了支援各種資料型別，已經變得複雜，但還是只能支援陣列、順序型的資料結構，如果想要支援非順序型的資料結構，如 stack、heap、hash table、tree、graph，那實在是複雜到寫不下去了。</p>
<p>透過以上幾個範例可以發現 C 語言的問題</p>
<ul>
<li>如果一個算法想支援不同的資料型別，必須使用 void* 或巨集，導致型別檢查過於寬鬆，容易產生錯誤。</li>
<li>抽象後的資料型別，無法取得 size，必須由呼叫者自己處理。</li>
<li>更複雜的泛型不只要支援不同的資料型別，還要支援不同的資料結構（資料是在結構裡面），而不同資料結構要處理記憶體分配與釋放、物件之間的複製，其中還有 shallow copy 的問題，造成程式碼複雜度劇增。</li>
</ul>
<p>C 語言至今沒有解決這些問題，因為當初設計的目的、思想就已經決定 C 語言注定不適合高階、抽象的程式設計方法，所以才有了 C++。</p>
<h2 id="c-語言-1">C++ 語言<a hidden class="anchor" aria-hidden="true" href="#c-語言-1">#</a></h2>
<p>早期 C++ 許多功能是對 C 語言的強化、改進，且把兼容 C 作為強制要求，所以 C++ 才設計得這麼複雜；而 C 語言的 C89、C99 也參考了 C++ 做了很多改進。</p>
<blockquote>
<p>九二共識就是沒有共識，我只知道九九共識，依循 C99 規格開發程式。</p></blockquote>
<p>C++ 解決了 C 的許多問題</p>
<ul>
<li>用 reference 解決指標的問題</li>
<li>用 namespace 解決命名衝突問題</li>
<li>用 try-catch 解決檢查返回值的問題</li>
<li>用 class 解決物件建立、複製、刪除的問題</li>
<li>用 operator overloading 達到操作上的泛型，比如上一篇的 cmpFn 比較函式，再比如 &gt;&gt; 操作符消除 printf() 的資料結構不夠泛型的問題</li>
<li>用 template、virtual function、RTTI 達到更高層次的泛型與多型</li>
<li>用 RAII、smart pointers，解決 C 語言中為了釋放資源而寫的骯髒、容易錯的程式碼</li>
<li>用 STL 解決 C 語言中資料結構、演算法的問題</li>
</ul>
<h2 id="c-的泛型">C++ 的泛型<a hidden class="anchor" aria-hidden="true" href="#c-的泛型">#</a></h2>
<p>理想情況下算法與資料型別、資料結構都無關，各種資料結構應該自己處理份內的工作，而算法只關心一個標準的實作方法；而泛型程式設計需要解決幾個問題</p>
<ul>
<li>算法的泛型</li>
<li>資料型別的泛型</li>
<li>資料結構(資料的容器)的泛型</li>
</ul>
<p>C++ 透過幾種方式解決泛型問題，能夠寫出基於抽象的介面的泛型</p>
<ul>
<li>透過類別(class)解決資料型別、資料結構的問題
<ul>
<li>類別裡面有建構子、解構子，處理資源的分配、釋放</li>
<li>複製建構子，表示對記憶體的複製</li>
<li>運算子重載，處理比較的問題</li>
<li>這樣自訂的資料型別用起來就跟內建的一樣</li>
</ul>
</li>
<li>透過模板處理資料型別
<ul>
<li>模板會根據呼叫者的類型，在編譯時去生成那個模板的程式碼</li>
<li>模板可以用虛擬類型來綁定，就沒有資料型別轉換的問題</li>
<li>模板取代了 C 語言的巨集，並解決了巨集的問題</li>
</ul>
</li>
<li>虛擬函式、RTTI
<ul>
<li>虛擬函式的多型，在語法上可以支援同一類的型別的泛型</li>
<li>泛型時 RTTI 可以對具體類型做特殊處理</li>
</ul>
</li>
</ul>
<h2 id="c-泛型範例-search-function">C++ 泛型範例 search function<a hidden class="anchor" aria-hidden="true" href="#c-泛型範例-search-function">#</a></h2>
<p>之前 C 版本的 search() 還有幾個問題</p>
<ul>
<li>透過 for(int i=0; i&lt;len; i++) 的走訪方式，不適用於非順序型資料結構，如 hash table、tree、graph，需要改成泛型的操作（走訪、增刪改查）</li>
<li>search 返回 int 型別的索引位置，假設換成 hash table，因為資料不是連續的，索引位置沒有意義，所以返回的要改成某種 key，所以泛型的 search 要改成返回這個元素的指標才通用</li>
</ul>
<p>來看看 C++ 如何解決以上問題</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> Iter<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Iter search(Iter pStart, Iter pEnd, T target)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(Iter p <span style="color:#f92672">=</span> pStart; p<span style="color:#f92672">!=</span> pEnd; p<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>p <span style="color:#f92672">==</span> target)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>這段程式用了 C++ 的幾個技術來解決 C 的問題</p>
<ul>
<li>用 typename T 抽象了資料結構中儲存資料的型別</li>
<li>用 typename Iter 抽象了資料結構，不同資料結構自己要實作迭代器</li>
<li>Iter 的 ++ 方法抽象了走訪方法，不同資料結構自己要實作運算子重載</li>
<li>用 *Iter 取得指標指向的值，* 取值操作符也需要重載</li>
</ul>
<p>如果習慣 Java 可能會覺得 Iter.Next() 比 ++ 好，用 Iter.GetValue() 比 * 好，但主要是 C++ 需要兼容 C 的習慣。</p>
<p>實際 C++ STL 裡的 find() 是這樣，很類似我們寫的 search 方法，只是他用 while loop</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIterator</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>InputIterator find (InputIterator first, InputIterator last, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (first<span style="color:#f92672">!=</span>last) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>first<span style="color:#f92672">==</span>val) <span style="color:#66d9ef">return</span> first;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>first;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> last;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>到此 search function 的泛型設計就完成了，但其實 search() 遇到的問題只是一小部分，還有其他問題能夠讓泛型設計變得更複雜。讓我們來看看另一個 sum function 的例子。</p>
<h2 id="c-泛型範例-sum-function">C++ 泛型範例 sum function<a hidden class="anchor" aria-hidden="true" href="#c-泛型範例-sum-function">#</a></h2>
<p>先看 C 語言版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">size_t</span> size) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">+=</span> a[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>C++ 的版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> Iter<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T sum(Iter pStart, Iter pEnd) {
</span></span><span style="display:flex;"><span>    T result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(Iter p<span style="color:#f92672">=</span>pStart; p<span style="color:#f92672">!=</span>pEnd; p<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">+=</span> <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>這段程式有幾個問題，特別是 T result = 0; 這一行</p>
<ul>
<li>T 假設了 Iter 中返回的資料型別是 T</li>
<li>= 0 假設資料型別是 int</li>
</ul>
<p>如果資料型別不同，出現轉型，會有非常奇怪的 bug。</p>
<h2 id="c-泛型技術-迭代器">C++ 泛型技術 迭代器<a hidden class="anchor" aria-hidden="true" href="#c-泛型技術-迭代器">#</a></h2>
<p>Iter 在呼叫時，會類似 <code>vector&lt;int&gt;::iterator</code>，這個 declaration 已經把 int 傳進 Iter，所以 result 的 T 可以從 Iter 取得，這樣可以保證資料型別一致。所以我們需要實作一個迭代器(參考 STL，省略部分程式)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">container</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">iterator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typedef</span> iterator self_type;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typedef</span> T   value_type;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typedef</span> T<span style="color:#f92672">*</span>  pointer;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typedef</span> T<span style="color:#f92672">&amp;</span>  reference;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        reference <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>();
</span></span><span style="display:flex;"><span>        pointer <span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> self_type<span style="color:#f92672">&amp;</span> rhs);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">!=</span>(<span style="color:#66d9ef">const</span> self_type<span style="color:#f92672">&amp;</span> rhs);
</span></span><span style="display:flex;"><span>        self_type <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>() { self_type i <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; ptr_<span style="color:#f92672">++</span>; <span style="color:#66d9ef">return</span> i; }
</span></span><span style="display:flex;"><span>        self_type <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span> junk) { ptr_<span style="color:#f92672">++</span>; <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...省略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        pointer _ptr;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    iterator <span style="color:#a6e22e">begin</span>();
</span></span><span style="display:flex;"><span>    iterator <span style="color:#a6e22e">end</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...省略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>有幾個關鍵點</p>
<ul>
<li>迭代器是對某容器的具體實作，所以要跟容器在一起</li>
<li>要重載一些操作符，如：* 取值操作、-&gt; 成員操作、== 比較操作、!= 比較操作、++ 走訪操作</li>
<li>typedef 一些資料型別，如 value_type，說明容器內的資料的實際型別為何</li>
<li>begin()、end() 基本功能</li>
<li>有個指標 _ptr 用來指向當前資料，就是 T*</li>
</ul>
<p>再來要解決 T result = 0; 中 = 0 的問題，這需要由呼叫方傳入，改良後如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Iter</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> Iter<span style="color:#f92672">::</span>value_type
</span></span><span style="display:flex;"><span>sum(Iter start, Iter end, T init) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> Iter<span style="color:#f92672">::</span>value_type result <span style="color:#f92672">=</span> init;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">!=</span> end) {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> result <span style="color:#f92672">+</span> <span style="color:#f92672">*</span>start;
</span></span><span style="display:flex;"><span>        start<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>於是呼叫方可以這樣寫</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>container<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>container<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> c.begin();
</span></span><span style="display:flex;"><span>sum(c.begin(), c.end(), <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>解決了所有問題，這就是整個 STL 的泛型，包含了</p>
<ul>
<li>泛型的資料結構(資料容器)</li>
<li>泛型資料結構的迭代器</li>
<li>泛型的算法，目前 sum() 是單純累加，但要寫其他算法也很容易擴充了</li>
</ul>
<h2 id="更多的抽象">更多的抽象<a hidden class="anchor" aria-hidden="true" href="#更多的抽象">#</a></h2>
<p>來看一個更泛型的例子，有個資料結構 Employee，裡面有 vacation 休假日數、salary 薪資</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Employee</span> {
</span></span><span style="display:flex;"><span>    string id;
</span></span><span style="display:flex;"><span>    string name;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> vacation;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> salary;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果想計算員工的薪資總和、休假總天數</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>Employee<span style="color:#f92672">&gt;</span> staff;
</span></span><span style="display:flex;"><span>sum(staff.begin(), staff.end(), <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>會發現 sum() 不知道要怎麼寫，因為加總的會是不同的欄位，就算 Employee 有重載 + 運算子，也不知道要加總哪個欄位。</p>
<p>還有更多需求，如求平均值、最小值、最大值、中位數，算法和 sum() 是一樣的，只是其中的累加 + 會變成其他操作。</p>
<p>我希望算法只要負責走訪，具體的操作由呼叫者自己定義，這樣程式碼會更通用，例如一個更抽象的算法 reduce()，用來把陣列 reduce 成一個值，至於怎麼變成一個值，則由呼叫者提供的函式來決定。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Iter</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Op</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T reduce(Iter start, Iter end, T init, Op op) {
</span></span><span style="display:flex;"><span>    T result <span style="color:#f92672">=</span> init;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (start <span style="color:#f92672">!=</span> end) {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> op(result, <span style="color:#f92672">*</span>start);
</span></span><span style="display:flex;"><span>        start<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>算法和 sum() 一樣，但不是單純累加，而是迭代器提供一個函數物件 operation 來處理具體操作。</p>
<p>C++ STL 中，有個類似的函數 accumulate()，原始碼有二個版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T accumulate(InputIt first, InputIt last, T init)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (; first <span style="color:#f92672">!=</span> last; <span style="color:#f92672">++</span>first) {
</span></span><span style="display:flex;"><span>        init <span style="color:#f92672">=</span> init <span style="color:#f92672">+</span> <span style="color:#f92672">*</span>first;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> init;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>第二個版本更抽象，因為需要傳入一個二元操作函式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BinaryOperation</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T accumulate(InputIt first, InputIt last, T init, 
</span></span><span style="display:flex;"><span>             BinaryOperation op)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (; first <span style="color:#f92672">!=</span> last; <span style="color:#f92672">++</span>first) {
</span></span><span style="display:flex;"><span>        init <span style="color:#f92672">=</span> op(init, <span style="color:#f92672">*</span>first);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> init;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>呼叫時，可以用 C++ 的 lambda 表達式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> sum_salaries <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>    reduce(staff.begin(), staff.end(), <span style="color:#ae81ff">0.0</span>,
</span></span><span style="display:flex;"><span>        [](<span style="color:#66d9ef">double</span> s, Employee e)
</span></span><span style="display:flex;"><span>            { <span style="color:#66d9ef">return</span> s <span style="color:#f92672">+</span> e.salary; });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> max_salary <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    reduce( staff.begin(), staff.end(), <span style="color:#ae81ff">0.0</span>,
</span></span><span style="display:flex;"><span>        [](<span style="color:#66d9ef">double</span> s, Employee e)
</span></span><span style="display:flex;"><span>            { <span style="color:#66d9ef">return</span> s <span style="color:#f92672">&gt;</span> e.salary <span style="color:#f92672">?</span> s : e.salary; });
</span></span></code></pre></div><h2 id="reduce-函式">Reduce 函式<a hidden class="anchor" aria-hidden="true" href="#reduce-函式">#</a></h2>
<p>reduce 還可以完成更複雜的功能，例如計算薪水超過 5 萬的員工人數。</p>
<p>先定義一個函式物件 counter，counter 需要一個 Cond 函式物件，用來判斷是否符合條件，符合的話會加 1，不符合加 0。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cond</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">counter</span> {
</span></span><span style="display:flex;"><span>    size_t <span style="color:#a6e22e">operator</span>()(size_t c, T t) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> c <span style="color:#f92672">+</span> (Cond(t) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>然後用 counter、reduce 二個函式物件來寫一個 count_if 算法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Iter</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cond</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>size_t count_if(Iter begin, Iter end, Cond c) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">reduce</span>(begin, end, <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        counter<span style="color:#f92672">&lt;</span>Iter<span style="color:#f92672">::</span>value_type, Cond<span style="color:#f92672">&gt;</span>(c));
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>至於 Cond 實際是什麼條件，不是算法負責，而是由呼叫方決定，於是想要計算薪水超過 5 萬的員工人數，可以這樣寫。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>size_t count <span style="color:#f92672">=</span> count_if(staff.begin(), staff.end(),
</span></span><span style="display:flex;"><span>    [](Employee e){ <span style="color:#66d9ef">return</span> e.salary <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">50000</span>; });
</span></span></code></pre></div><p>從 C 到 C++，與 reduce() 的範例，可以了解發現程式語言需要處理二件事情</p>
<ul>
<li>資料型別問題</li>
<li>抽象、可重複用、組合</li>
</ul>
<p>不同語言解決的方法不一定都是 C++ 這種方式，但原理是相通的；因此接下來繼續深入討論程式語言的型別系統、與泛型程式設計的本質。</p>
<h2 id="型別系統-type-system">型別系統 type system<a hidden class="anchor" aria-hidden="true" href="#型別系統-type-system">#</a></h2>
<p>型別系統用來把程式語言中的數值、表達式做分類，以及定義這些型別能如何操作，一般分成二種</p>
<ul>
<li>基本資料型別，如 int、float、char</li>
<li>抽象資料型別，如 struct、class、function</li>
</ul>
<p>型別系統的功能如下</p>
<ul>
<li>安全性：編譯器會檢查語法錯誤，例如 “hello, world” + 1，強型別的語言可以提供更高安全性。</li>
<li>優化：靜態類型的語言，能讓編譯器知道變數的資料型別，編譯器就能做優化；如：int 可以知道這個類型以 4 byte 的倍數對齊，編譯器能使用更有效率的機器碼指令。</li>
<li>抽象化：型別可以讓人用更高層次思考；例如可以把 string 當成一個值，而不是底層的 char array；不同函式之間的參數、返回值的型別，也可以讓介面更語意化。</li>
</ul>
<p>但就如前面遇到的問題，型別系統會造成，就算不同型別的算法的程式碼長得一樣，卻為了不同型別而需要寫 N 多種，如果要做泛型，就只能用更底層的方法；因此這個世界出現了動態類型的語言，例如：</p>
<pre tabindex="0"><code>x = 5;
x = &#34;hi&#34;;
</code></pre><p>靜態語言在編譯時會出語法錯誤；但在動態語言中，會使用型別標記維持程式所有數值的標記（不是變數），在運算前會先檢查標記，所以變數的類型不是透過型別定義，而是解釋器在運行時動態標記的，在運行時才動態的對應底層指令、記憶體佈局。</p>
<p>再來像 JavaScript 還可以定義一個包含各種型別的類型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Array();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2022</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hi&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Marcus&#34;</span>};
</span></span></code></pre></div><p>其實這並不是 array，而是一個 key value，因為動態語言的型別是動態的，所以 key、value 的型別都可以不同，還可以寫成 a[“key”] = “value”;</p>
<p>因此在動態語言中會因為類型，而出現不確定的結果</p>
<pre tabindex="0"><code>x = 3;
y = &#34;5&#34;;
z = x + y;
</code></pre><ul>
<li>JavaScript 會把數字 3 轉成字串，然後運算子 + 會把字串拼接起來，結果是 “35”</li>
<li>Python 會發生 runtime error</li>
<li>Visual Basic 會把字串 5 轉成數字，結果是 8</li>
</ul>
<p>程式語言的型別系統歸納如下</p>
<ul>
<li>靜態類型，在編譯時進行語法分析，型別錯誤是 syntax error
<ul>
<li>如果允許自動轉型，則稱為弱型別</li>
<li>如果強制類型規則（只允許資料不丟失的轉型），則稱為強型別</li>
</ul>
</li>
<li>動態類型，在運行時做動態標記，型別錯誤是 runtime error；所以動態類型語言會提供很多類型檢查的函式：is_array()、in_int()、is_string()、typeof()&hellip;</li>
</ul>
<p>總之，所有語言都有型別系統，型別是對底層記憶體佈局做抽象，讓我們可以專心在上層的邏輯；靜態語言好處是編譯器的檢查、增加運行時效能；而動態語言優點是程式碼更簡單、寫得更輕鬆快速。</p>
<p>但在程式碼複雜度方面，動態語言不一定永遠是比較簡單的，如果某個系統需要明確的型別，或者型別不符會產生錯誤時，就會看到動態語言需要寫額外的型別檢查，這不只囉唆，且性能比較差，例如 JavaScript 要寫一個轉型的函式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ToNumber</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span>(<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;number&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;undefined&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">NaN</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;boolean&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;string&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">return</span> Number(<span style="color:#a6e22e">x</span>); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;object&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">NaN</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;function&#34;</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">NaN</span>;    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="泛型的本質">泛型的本質<a hidden class="anchor" aria-hidden="true" href="#泛型的本質">#</a></h2>
<p>泛型的本質，就是型別的本質。</p>
<ul>
<li>型別是底層記憶體佈局的抽象，不同型別有不同的憶體佈局、分配方式</li>
<li>不同型別有不同操作</li>
</ul>
<p>要做到泛型，需要滿足以下要求</p>
<ul>
<li>抽象掉型別的記憶體訪問、分配、釋放</li>
<li>抽象掉型別的操作，比較、複製、I/O…</li>
<li>抽象掉資料結構(資料的容器)的操作，搜尋、過濾、aggregation…</li>
<li>抽象掉型別的特殊操作要有標準的介面去 callback 不同型別的實際具體操作</li>
</ul>
<p>以 C++ 而言解決泛型的技術如下；許多程式語言的泛型設計，多少都參考了 C++</p>
<ul>
<li>類別的建構子、解構子、複製建構子、運算子重載，抽象掉型別的記憶體訪問、分配、釋放</li>
<li>運算子重載，抽象掉比較之類的操作</li>
<li>iostream 抽象掉型別的輸入、輸出控制</li>
<li>用 template 來幫不同型別生成專屬的程式碼</li>
<li>用迭代器抽象掉資料結構的走訪</li>
<li>virtual function 來抽象掉特定型別在算法上的實際操作</li>
<li>函數物件抽象掉對於不同型別的特殊操作</li>
</ul>
<p>泛型就是隱藏資料、操作資料的細節，讓算法更通用，讓我們能專注在算法，而不需要處理算法中不同的資料型別。</p>
<blockquote>
<p>Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software.  — Musser, David R.; Stepanov, Alexander A., Generic Programming</p></blockquote>
<p>程式語言作為人操作機器的媒介，究竟要給予更大的操作自由，還是隱藏底層，方便抽象的思考，二者的取捨，C 語言選擇了前者，而 Java 選擇了後者。</p>
<p>瞭解程式語言的設計與取捨，就明白為何這個語言發展成現在的模樣，無論在程式寫作、或學習新的語言時，都能從中有所收穫。</p>
<h2 id="reference">reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<ol>
<li><a href="http://stepanovpapers.com/genprog.pdf">http://stepanovpapers.com/genprog.pdf</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1">https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://marc-tech.zeabur.app/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/">程式設計</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://marc-tech.zeabur.app/posts/functional-programming/">
    <span class="title">« Prev</span>
    <br>
    <span>Functional programming 到底是什麼鬼</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://marc-tech.zeabur.app/"></a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
